<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seq2Seq 论文</title>
    <!-- 引入 Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .sidebar {
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            background-color: #f8f9fa;
            color: #000;
            border-right: 1px solid #ddd;
        }

        .custom-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: #4caf50;
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 3px solid #4caf50; /* 标题下边框 */
        }

        .title-subtext {
            font-size: 1.2rem;
            color: #6c757d; /* Bootstrap 灰色 */
            text-align: center;
        }
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: #f4f4f9;
            color: #333;
        }
        .content {
            padding: 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        /* 移动端样式（只在屏幕宽度 < 1024 px 时生效 */
        @media screen and (max-width: 1024px) {
            .sidebar, .right-sidebar {
                display: none; /* 隐藏侧边栏 */
            }
            .content {
                margin: 0;
                padding: 10px;
                width: 100%;
            }
        }
        .content h2 {
            width: 100%;
            font-size: 3rem;
            line-height: 1.6;
            color: #4caf50;
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 3px solid #4caf50;
            display: inline-block;
            padding-bottom: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
        }
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 16px;
            line-height: 1.5;
        }
        .added {
            color: #10e6e2;
            display: inline-block;
            width: 100%;
        }
        code {
            font-family: "Courier New", Courier, monospace;
        }
        .content h3 {
            margin-top: 60px;
            color: #8e44ad;
        }
        .content h4 {
            margin-top: 40px;
            color: #8e44ad;
        }
        .content p {
            font-size: 1.1em;
            margin: 20px 0;
        }
        .highlight-math {
            background-color: #FFCC99;
            padding: 5px;
            border-radius: 5px;
        }
        .highlight-link {
            color: #f39c12;
            font-weight: bold;
        }
        .highlight {
            background-color: #f1c40f;
            font-weight: bold;
        }
        pre {
            background: #263238;
            color: #c3e88d;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
            font-size: 0.9em;
        }
        ul {
            list-style: none;
            padding-left: 20px;
            margin: 10px 0;
        }
        .with-bullets {
            list-style: disc;
            padding-left: 10px;
            margin: 10px 0 10px 20px;
        }
        ul li {
            margin: 4px 0;
            color: #34495e;;
        }
        li .title {
            font-weight: bold;
            color: #2c3e50;
            font-size: 18px;
            margin-bottom: 6px;
        }
        li p {
            color: #34495e;
            font-size: 16px;
        }
        .right-sidebar {
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            padding: 20px;
            background-color: #f8f9fa;
            border-left: 1px solid #ddd;
        }
        .right-sidebar a {
            color: #343a40;
            text-decoration: none;
        }
        .right-sidebar a:hover {
            text-decoration: underline;
        }
        .right-sidebar .active {
            font-weight: bold;
            color: #007bff;
        }
        #dynamic-sidebar ul {
            list-style-type: none;
            padding-left: 0;
        }
        #dynamic-sidebar ul ul {
            padding-left: 20px;
        }
        a {
            text-decoration: underline;
            text-underline-offset: 4px;
            color: #3498db;
        }
        a:hover {
            color: #2c3e50;
        }
        img {
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15), 0 -2px 6px rgba(0, 0, 0, 0.1);;
        }
        .comment {
            color: #6c757d;
            font-size: 0.9em;
            font-style: italic;
            margin: 20px 0;
            border-left: 3px solid #d6d8db;
            padding-left: 10px;
        }
        table {
            width: 50%;
            border-collapse: collapse;
            margin: 20px auto;
            font-family: Arial, sans-serif;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: center;
        }
        th {
            background-color: #f4f4f4;
        }
        .positive {
            color: green;
            font-weight: bold;
        }
        .negative {
            color: red;
            font-weight: bold;
        }
        .scroll-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .navigation {
            margin-top: 30px;
            background-color: #f0f0f0;
            display: flex;
            justify-content: space-between;
            position: relative;
            overflow: hidden;
        }
        .navigation a {
            text-decoration: none;
            color: #007bff;
            font-size: 20px;
            padding: 10px 30px;
        }
        .navigation a:hover {
            text-decoration: underline;
        }
        .paper-comment {
            background-color: pink;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
            border: 1px solid #ff69b4;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="row">
        <!-- 左侧小节列表 -->
        <nav class="col-md-2 sidebar">

        </nav>

        <!-- 中间内容：显示具体某一个小节 -->
        <main class="col-md-8 content">
            <h2 class="custom-title">8.7 Seq2Seq 论文</h2>
            <p class="title-subtext">利用神经网络进行序列到序列学习！</p>
            <p style="color: #a0a0a0;">创建日期: 2025-02-06</p>
            <p>深度神经网络 (DNN) 是一种功能强大的模型，在困难的学习任务上取得了出色的表现。尽管只要有大型标记训练集可用，DNN 就能很好地工作，但它们不能用于将序列映射到序列。</p>
            <p>在本文中，我们提出了一种通用的端到端序列学习方法，该方法对序列结构做出最少的假设。我们的方法使用多层长短期记忆 (LSTM) 将输入序列映射到固定维数的向量，然后使用另一个深度 LSTM 从向量中解码目标序列。</p>
            <p>我们的主要结果是，在 WMT 14 数据集的英语到法语的翻译任务中，LSTM 生成的翻译在整个测试集上获得了 34.8 的 BLEU 分数，其中 LSTM 的 BLEU 分数因词汇表以外的单词而受到惩罚。</p>
            <p>此外，LSTM 在处理长句时没有遇到困难。相比之下，基于短语的统计机器翻译 (SMT) 系统在同一数据集上实现了 33.3 的 BLEU 分数。当我们使用 LSTM 对上述 SMT 系统产生的 1000 个假设进行重新排序时，其 BLEU 分数增加到 36.5，这接近该任务之前的最佳结果。</p>
            <p>LSTM 还学习了合理的短语和句子表示，这些表示对词序敏感，并且对主动语态和被动语态相对不变。最后，我们发现，反转所有源句子（但不是目标句子）中的单词顺序可以显著提高 LSTM 的性能，因为这样做会在源句子和目标句子之间引入许多短期依赖关系，从而使优化问题变得更容易。</p>
            
            <h3>8.7.1 介绍</h3>
            <p>深度神经网络 (DNN) 是一种非常强大的机器学习模型，在语音识别和视觉对象识别等难题上取得了出色的表现。DNN 强大功能的一个令人惊讶的例子是，它们能够仅使用 2 个二次大小的隐藏层对 N 位数进行排序。因此，虽然神经网络与传统统计模型相关，但它们学习的是复杂的计算。</p>
            <p>此外，只要标记训练集具有足够的信息来指定网络的参数，就可以使用监督反向传播来训练大型 DNN。因此，如果存在一个大型 DNN 的参数设置可以实现良好的结果（例如，因为人类可以非常快速地解决任务），监督反向传播将找到这些参数并解决问题。</p>
            <p>尽管 DNN 具有灵活性和强大功能，但它只能应用于输入和目标可以用固定维数的向量合理编码的问题。这是一个很大的限制，因为许多重要问题最好用长度未知的序列来表达。</p>
            <p>例如，语音识别和机器翻译是顺序问题。同样，问答也可以看作是将表示问题的单词序列映射到表示答案的单词序列。因此，很明显，一种独立于领域的、学习将序列映射到序列的方法将会很有用。</p>
            <p>序列对 DNN 提出了挑战，因为它们要求输入和输出的维数是已知且固定的。在本文中，我们展示了长短期记忆 (LSTM) 架构的直接应用可以解决一般的序列到序列问题。</p>
            <p>这个想法是使用一个 LSTM 一次读取一个时间步长的输入序列，以获得大的固定维度向量表示，然后使用另一个 LSTM 从该向量中提取输出序列，如下图所示：</p>
            <img src="res/seq2seq.svg" alt="序列到序列">
            <p>第二个 LSTM 本质上是一个循环神经网络语言模型，只不过它以输入序列为条件。由于输入与其对应输出之间存在相当大的时间滞后，LSTM 能够成功地学习具有长距离时间依赖性的数据，因此它自然而然地成为此应用的选择。</p>
            <p>已经有许多相关尝试来解决使用神经网络的一般序列到序列学习问题。我们的方法与 Kalchbrenner 和 Blunsom [18] 密切相关，他们是第一个将整个输入句子映射到向量的人，并且与 Cho 等人 [5] 相关，尽管后者仅用于重新评分基于短语的系统产生的假设。</p>
            <p>Graves 引入了一种新颖的可区分注意力机制，允许神经网络关注其输入的不同部分，并且这个想法的一个优雅变体被 Bahdanau 等人成功应用于机器翻译。连接主义序列分类是另一种流行的使用神经网络将序列映射到序列的技术，但它假设输入和输出之间存在单调对齐。</p>
            
            <p>这项工作的主要成果如下，在 WMT’14 英语到法语的翻译任务中，我们使用简单的从左到右波束搜索解码器直接从 5 个深度 LSTM（每个具有 384M 个参数和 8,000 维状态）的集合中提取翻译，获得了 34.81 的 BLEU 分数。这是迄今为止使用大型神经网络直接翻译所取得的最佳结果。</p>
            <p>作为比较，此数据集上 SMT 基线的 BLEU 分数为 33.30 [29]。34.81 的 BLEU 分数是由词汇量为 80k 单词的 LSTM 获得的，因此只要参考翻译包含这 80k 未涵盖的单词，就会对分数进行惩罚。该结果表明，相对未优化的小词汇量神经网络架构有很大的改进空间，其性能优于基于短语的 SMT 系统。</p>
            <p>最后，我们使用 LSTM 对同一任务 [29] 上公开可用的 SMT 基线 1000 个最佳列表进行重新评分。通过这样做，我们获得了 36.5 的 BLEU 分数，这使基线提高了 3.2 个 BLEU 点，并且接近之前在此任务上发布的最佳结果（即 37.0）。</p>
            <p>令人惊讶的是，尽管其他研究人员最近对相关架构有过研究，但 LSTM 在处理非常长的句子时并没有受到影响 [26]。我们之所以能够在长句子上取得良好的成绩，是因为我们颠倒了源句子中的单词顺序，但没有颠倒训练和测试集中的目标句子中的单词顺序。</p>
            <p>通过这样做，我们引入了许多短期依赖关系，使优化问题变得简单得多（参见第 2 节和 3.3 节）。因此，SGD 可以学习对长句子没有问题的 LSTM。反转源句子中的单词的简单技巧是这项工作的关键技术贡献之一。</p>
            <p>LSTM 的一个有用特性是它学会将可变长度的输入句子映射到固定维度的向量表示中。鉴于翻译往往是源句子的释义，翻译目标鼓励 LSTM 找到能够捕捉其含义的句子表示，因为具有相似含义的句子彼此接近，而不同句子的含义则会相距甚远。定性评估支持这一说法，表明我们的模型能够识别词序，并且对主动和被动语态相当不变。</p>

            <h3>8.7.2 模型</h3>
            <p>循环神经网络 (RNN) 是前馈神经网络对序列的自然推广。给定一个输入序列 \((x_1, ... , x_T)\) ，一个标准的 RNN 通过迭代下述等式获得系列输出 \((y_1, ... , y_T)\)：</p>
            <p class="highlight-math" style="text-align: center;"> \(h_t = sigm(W^{hx}x_t + W^{hh}h_{t-1})\)</p>
            <p class="highlight-math" style="text-align: center;"> \(y_t = W^{yh}h_t\)</p>
            <p>只要提前知道输入和输出之间的对齐，RNN 就可以轻松地将序列映射到序列。然而，目前尚不清楚如何将 RNN 应用于输入和输出序列长度不同且关系复杂且非单调的问题。</p>
            <p>一般序列学习的最简单策略是使用一个 RNN 将输入序列映射到固定大小的向量，然后使用另一个 RNN 将向量映射到目标序列（这种方法也已被 Cho 等人采用 [5]）。虽然理论上它可以工作，因为 RNN 提供了所有相关信息，但由于由此产生的长期依赖关系，训练 RNN 会很困难（图 1）[14、4、16、15]。然而，众所周知，长短期记忆 (LSTM)[16] 可以学习具有长距离时间依赖性的问题，因此 LSTM 可能在这种情况下取​​得成功。</p>

            <h3>8.7.3 实验</h3>

            <h4>8.7.3.1 数据集</h4>

            <h4>8.7.3.2 解码与重评分</h4>

            <h4>8.7.3.3 反向源句子</h4>
            
            <h4>8.7.3.4 训练详情</h4>

            <h4>8.7.3.5 并行化</h4>

            <h4>8.7.3.6 实验结果</h4>

            <h4>8.7.3.7 长句子表现</h4>

            <h4>8.7.3.8 模型分析</h4>

            <h3>8.7.4 相关工作</h3>

            <h4>8.7.5 总结</h4>

            <h3>8.7.6 致谢与参考</h3>


            <div class="navigation">
                <a href="rnn_translate.html">上一节：8.6 RNN 翻译</a>
                <a href="#">下一节：8.8 Word2Vec 论文</a>
            </div>
        </main>

            <!-- 右侧小标题导航 -->
            <aside class="col-md-2 right-sidebar">
                <h5><a href="index.html#section8">循环神经网络</a></h5>
                <ul id="dynamic-sidebar" class="nav flex-column">
                    <!-- 动态内容 -->
                </ul>
            </aside>
        </div>
    </div>

        <!-- 引入 Bootstrap JS -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

        <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>

        <script>
            // 获取所有的 h3 和 h4 元素
            const sidebar = document.getElementById('dynamic-sidebar');
            const elements = Array.from(document.querySelectorAll('h3, h4')); // 获取所有 h3 和 h4 元素

            // 动态生成目录项
            elements.forEach(element => {
                // 如果没有 id，则为该元素生成一个 id
                if (!element.id) {
                    element.id = `${element.tagName.toLowerCase()}-${Math.random().toString(36).substr(2, 9)}`;
                }

                const link = document.createElement('a');
                link.href = `#${element.id}`;
                link.textContent = element.textContent;

                const listItem = document.createElement('li');
                // 如果是 h4 元素，添加缩进
                if (element.tagName.toLowerCase() === 'h4') {
                    listItem.style.marginLeft = '20px'; // 控制缩进
                }
                listItem.appendChild(link);

                sidebar.appendChild(listItem);
            });

            // 高亮当前目录项
            function highlightCurrentLink(targetId) {
                const links = sidebar.querySelectorAll('a');
                links.forEach(link => {
                    if (link.getAttribute('href') === `#${targetId}`) {
                        link.classList.add('highlight-link');
                    } else {
                        link.classList.remove('highlight-link');
                    }
                });
            }

            // 页面滚动时更新高亮
            window.addEventListener('scroll', () => {
                let found = false;
                elements.forEach(el => {
                    const rect = el.getBoundingClientRect();
                    if (rect.top <= window.innerHeight / 2 && rect.bottom >= 0) {
                        if (!found) {
                            highlightCurrentLink(el.id);
                            found = true;
                        }
                    }
                });
            });

            // 为每个目录链接添加点击事件
            const links = sidebar.querySelectorAll('a');
            links.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth' });
                        highlightCurrentLink(targetId);
                    }
                });
            });
        </script>
</body>
</html>